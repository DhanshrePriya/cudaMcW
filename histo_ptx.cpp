#include <cuda.h>
#include <iostream>
#include <vector>
#include <cassert>
#include <stdio.h>

#define NUM_BINS 256

const char *ptx_source = R"(
//
// Generated by NVIDIA NVVM Compiler
//
// Compiler Build ID: CL-26907403
// Cuda compilation tools, release 10.1, V10.1.243
// Based on LLVM 3.4svn
//

.version 6.4
.target sm_30
.address_size 64

	// .globl	_Z6kernelPfPii

.visible .entry _Z6kernelPfPii(
	.param .u64 _Z6kernelPfPii_param_0,
	.param .u64 _Z6kernelPfPii_param_1,
	.param .u32 _Z6kernelPfPii_param_2
)
{
	.reg .pred 	%p<2>;
	.reg .f32 	%f<2>;
	.reg .b32 	%r<8>;
	.reg .b64 	%rd<9>;


	ld.param.u64 	%rd1, [_Z6kernelPfPii_param_0];
	ld.param.u64 	%rd2, [_Z6kernelPfPii_param_1];
	ld.param.u32 	%r2, [_Z6kernelPfPii_param_2];

	mov.u32 	%r3, %ctaid.x;
	mov.u32 	%r4, %ntid.x;
	mov.u32 	%r5, %tid.x;
	mad.lo.s32 	%r1, %r4, %r3, %r5;
	setp.ge.s32	%p1, %r1, %r2;
	@%p1 bra 	BB0_2;
    
	cvta.to.global.u64 	%rd3, %rd1;
	mul.wide.s32 	%rd4, %r1, 4;
	add.s64 	%rd5, %rd3, %rd4;
	ld.global.f32 	%f1, [%rd5];
	cvt.rzi.s32.f32	%r6, %f1;
	cvta.to.global.u64 	%rd6, %rd2;
	mul.wide.s32 	%rd7, %r6, 4;
	add.s64 	%rd8, %rd6, %rd7;
	atom.global.add.u32  %r7, [%rd8], 1; // r7 for storinmg older val of rd8


BB0_2:
	ret;
}

)";

int main() {
    CUdevice cuDevice;
    CUcontext cuContext;
    CUmodule cuModule;
    CUfunction cuFunction;
    CUdeviceptr d_image, d_hist;
    int N = 1 << 20;  
    size_t imgSize = N * sizeof(float);
    size_t histSize = NUM_BINS * sizeof(int);

    std::vector<float> h_image(N);
    std::vector<int> h_hist(NUM_BINS, 0);
    std::vector<int> h_hist_gpu(NUM_BINS, 0);
    
    for (int i = 0; i < N; i++) h_image[i] = rand() % NUM_BINS;

    cuInit(0);
    cuDeviceGet(&cuDevice, 0);
    cuCtxCreate(&cuContext, 0, cuDevice);

    cuModuleLoadData(&cuModule, ptx_source);
    cuModuleGetFunction(&cuFunction, cuModule, "_Z6kernelPfPii");

    cuMemAlloc(&d_image, imgSize);
    cuMemAlloc(&d_hist, histSize);
    cuMemcpyHtoD(d_image, h_image.data(), imgSize);
    cuMemsetD32(d_hist, 0, NUM_BINS);

    void *args[] = { &d_image, &d_hist, &N };

    CUevent start, stop;

    cuEventCreate(&start, CU_EVENT_DEFAULT);
    cuEventCreate(&stop, CU_EVENT_DEFAULT);
    cuEventRecord(start, 0);
 
    cuLaunchKernel(cuFunction, (N + 255) / 256, 1, 1, 256, 1, 1, 0, 0, args, 0);

    cuEventRecord(stop, 0);
    cuEventSynchronize(stop);
    float milliseconds = 0;
    cuEventElapsedTime(&milliseconds, start, stop);
    printf("Execution Time: %f ms\n", milliseconds);
 
    cuMemcpyDtoH(h_hist_gpu.data(), d_hist, histSize);

    for (int i = 0; i < N; i++) h_hist[(int)h_image[i]]++;
    for (int i = 0; i < NUM_BINS; i++) {
        assert(h_hist[i] == h_hist_gpu[i]);
        //std::cout << h_hist_gpu[i] << std::endl;

    }
    std::cout << "Histogram verification correct!" << std::endl;

    cuMemFree(d_image);
    cuMemFree(d_hist);
    cuCtxDestroy(cuContext);
    return 0;
}
